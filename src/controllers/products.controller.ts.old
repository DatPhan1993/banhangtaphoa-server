import { Response } from 'express';
import Database from '../database/connection';
import SQLiteDatabase from '../database/sqlite-connection';
import { AuthRequest } from '../middleware/auth';
import { Product, CreateProductRequest, ApiResponse } from '../types';
import * as XLSX from 'xlsx';
import DatabaseConnection from '../database/connection';

export class ProductsController {
  async getProducts(req: AuthRequest, res: Response) {
    try {
      const { category_id, search, limit = 1000, offset = 0, is_active } = req.query;
      
      console.log('Get products called with params:', { category_id, search, limit, offset, is_active });
      
      // Build dynamic query
      let query = `
        SELECT p.*, c.name as category_name 
        FROM products p 
        LEFT JOIN categories c ON p.category_id = c.id 
        WHERE 1=1
      `;
      
      // Add search filter with word-based matching
      if (search && typeof search === 'string' && search.trim()) {
        const searchTerm = search.trim().replace(/'/g, "''"); // Escape single quotes
        const searchWords = searchTerm.split(/\s+/).filter(word => word.length > 0);
        
        if (searchWords.length > 0) {
          // Build search condition for each word (all words must match)
          const searchConditions = searchWords.map(word => {
            const escapedWord = word.replace(/'/g, "''");
            return `(
              p.name LIKE '%${escapedWord}%' OR 
              p.sku LIKE '%${escapedWord}%' OR 
              p.barcode LIKE '%${escapedWord}%' OR
              p.description LIKE '%${escapedWord}%'
            )`;
          });
          
          query += ` AND (${searchConditions.join(' AND ')})`;
        }
      }
      
      // Add category filter
      if (category_id && category_id !== '') {
        query += ` AND p.category_id = ${Number(category_id)}`;
      }
      
      // Add active filter
      if (is_active !== undefined) {
        query += ` AND p.is_active = ${is_active === 'true' ? 1 : 0}`;
      }
      
      // Add ordering and pagination
      query += ` ORDER BY p.name`;
      
      if (limit && limit !== 'all') {
        query += ` LIMIT ${Number(limit)}`;
        
        if (offset) {
          query += ` OFFSET ${Number(offset)}`;
        }
      }
      
      console.log('Executing query:', query);
      
      const db = Database.getInstance();
      const products = await db.all(query, []);
      
      console.log('Query executed successfully, results:', products.length);

      res.json({
        success: true,
        data: products
      });
    } catch (error) {
      console.error('Get products error:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  async getProduct(req: AuthRequest, res: Response) {
    try {
      const { id } = req.params;

      const product = await Database.getInstance().get(
        `SELECT p.*, c.name as category_name 
         FROM products p 
         LEFT JOIN categories c ON p.category_id = c.id 
         WHERE p.id = ?`,
        [id]
      );

      if (!product) {
        return res.status(404).json({
          success: false,
          error: 'Product not found'
        });
      }

      res.json({
        success: true,
        data: product
      });
    } catch (error) {
      console.error('Get product error:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }

  async createProduct(req: AuthRequest, res: Response) {
    try {
      const productData: CreateProductRequest = req.body;

      if (!productData.name || !productData.sku || !productData.sale_price) {
        return res.status(400).json({
          success: false,
          error: 'Name, SKU, and sale price are required'
        });
      }

      // Check if SKU already exists
      const existingProduct = await Database.getInstance().get(
        'SELECT id FROM products WHERE sku = ?',
        [productData.sku]
      );

      if (existingProduct) {
        return res.status(409).json({
          success: false,
          error: 'SKU already exists'
        });
      }

      const result = await Database.getInstance().run(
        `INSERT INTO products (
          sku, barcode, name, description, category_id, unit,
          purchase_price, sale_price, wholesale_price, stock_quantity,
          min_stock_level, image_url
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          productData.sku,
          productData.barcode || null,
          productData.name,
          productData.description || null,
          productData.category_id || null,
          productData.unit || 'cÃ¡i',
          productData.purchase_price || 0,
          productData.sale_price,
          productData.wholesale_price || null,
          productData.stock_quantity || 0,
          productData.min_stock_level || 0,
          productData.image_url || null
        ]
      );

      // Create inventory transaction for initial stock
      if (productData.stock_quantity && productData.stock_quantity > 0) {
        await Database.getInstance().run(
          `INSERT INTO inventory_transactions (
            product_id, transaction_type, reference_type, quantity, 
            unit_price, notes, user_id
          ) VALUES (?, 'in', 'adjustment', ?, ?, 'Initial stock', ?)`,
          [
            result.lastID,
            productData.stock_quantity,
            productData.purchase_price || 0,
            req.user?.id
          ]
        );
      }

      res.status(201).json({
        success: true,
        data: { id: result.lastID },
        message: 'Product created successfully'
      });
    } catch (error) {
      console.error('Create product error:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }

  async updateProduct(req: AuthRequest, res: Response) {
    try {
      const { id } = req.params;
      const updates = req.body;

      console.log('Updating product with ID:', id);
      console.log('Update data:', JSON.stringify(updates, null, 2));

      const result = await Database.getInstance().run(
        `UPDATE products SET 
         sku = COALESCE(?, sku),
         barcode = COALESCE(?, barcode),
         name = COALESCE(?, name),
         description = COALESCE(?, description),
         category_id = COALESCE(?, category_id),
         unit = COALESCE(?, unit),
         purchase_price = COALESCE(?, purchase_price),
         sale_price = COALESCE(?, sale_price),
         wholesale_price = COALESCE(?, wholesale_price),
         promo_price = COALESCE(?, promo_price),
         stock_quantity = COALESCE(?, stock_quantity),
         min_stock_level = COALESCE(?, min_stock_level),
         max_stock_level = COALESCE(?, max_stock_level),
         expiry_date = COALESCE(?, expiry_date),
         image_url = COALESCE(?, image_url),
         has_variants = COALESCE(?, has_variants),
         track_inventory = COALESCE(?, track_inventory),
         is_active = COALESCE(?, is_active),
         updated_at = NOW()
         WHERE id = ?`,
        [
          updates.sku,
          updates.barcode,
          updates.name,
          updates.description,
          updates.category_id,
          updates.unit,
          updates.purchase_price,
          updates.sale_price,
          updates.wholesale_price,
          updates.promo_price,
          updates.stock_quantity,
          updates.min_stock_level,
          updates.max_stock_level,
          updates.expiry_date,
          updates.image_url,
          updates.has_variants,
          updates.track_inventory,
          updates.is_active,
          id
        ]
      );

      console.log('Update result:', result);

      if (result.affectedRows === 0) {
        return res.status(404).json({
          success: false,
          error: 'Product not found'
        });
      }

      // Get updated product to return
      const updatedProduct = await Database.getInstance().get(
        `SELECT p.*, c.name as category_name 
         FROM products p 
         LEFT JOIN categories c ON p.category_id = c.id 
         WHERE p.id = ?`,
        [id]
      );

      res.json({
        success: true,
        message: 'Product updated successfully',
        data: updatedProduct
      });
    } catch (error) {
      console.error('Update product error:', error);
      console.error('Error details:', {
        message: error.message,
        code: error.code,
        errno: error.errno,
        sqlState: error.sqlState,
        sqlMessage: error.sqlMessage
      });
      res.status(500).json({
        success: false,
        error: 'Internal server error',
        details: error.message
      });
    }
  }

  async deleteProduct(req: AuthRequest, res: Response) {
    try {
      const { id } = req.params;

      const result = await Database.getInstance().run(
        'UPDATE products SET is_active = 0 WHERE id = ?',
        [id]
      );

      if (result.affectedRows === 0) {
        return res.status(404).json({
          success: false,
          error: 'Product not found'
        });
      }

      res.json({
        success: true,
        message: 'Product deleted successfully'
      });
    } catch (error) {
      console.error('Delete product error:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }

  async getLowStockProducts(req: AuthRequest, res: Response) {
    try {
      const products = await Database.getInstance().all(
        `SELECT p.*, c.name as category_name 
         FROM products p 
         LEFT JOIN categories c ON p.category_id = c.id 
         WHERE p.is_active = 1 AND p.track_inventory = 1 
         AND p.stock_quantity <= p.min_stock_level
         ORDER BY p.stock_quantity ASC`
      );

      res.json({
        success: true,
        data: products
      });
    } catch (error) {
      console.error('Get low stock products error:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }

  async adjustStock(req: AuthRequest, res: Response) {
    try {
      const { id } = req.params;
      const { quantity, notes } = req.body;

      if (quantity === undefined || quantity === 0) {
        return res.status(400).json({
          success: false,
          error: 'Quantity is required and must not be zero'
        });
      }

      // Get current product
      const product = await Database.getInstance().get(
        'SELECT * FROM products WHERE id = ?',
        [id]
      ) as Product;

      if (!product) {
        return res.status(404).json({
          success: false,
          error: 'Product not found'
        });
      }

      const newStock = product.stock_quantity + quantity;

      if (newStock < 0) {
        return res.status(400).json({
          success: false,
          error: 'Insufficient stock for this adjustment'
        });
      }

      // Update stock
      await Database.getInstance().run(
        'UPDATE products SET stock_quantity = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
        [newStock, id]
      );

      // Create inventory transaction
      await Database.getInstance().run(
        `INSERT INTO inventory_transactions (
          product_id, transaction_type, reference_type, quantity, 
          notes, user_id
        ) VALUES (?, ?, 'adjustment', ?, ?, ?)`,
        [
          id,
          quantity > 0 ? 'in' : 'out',
          Math.abs(quantity),
          notes || 'Stock adjustment',
          req.user?.id
        ]
      );

      res.json({
        success: true,
        message: 'Stock adjusted successfully',
        data: { new_stock: newStock }
      });
    } catch (error) {
      console.error('Adjust stock error:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }

  async deleteAllProducts(req: AuthRequest, res: Response) {
    try {
      // Get count before deletion
      const countResult = await Database.getInstance().get(
        'SELECT COUNT(*) as count FROM products WHERE is_active = 1'
      ) as { count: number };

      // Soft delete all products
      const result = await Database.getInstance().run(
        'UPDATE products SET is_active = 0, updated_at = CURRENT_TIMESTAMP WHERE is_active = 1'
      );

      res.json({
        success: true,
        data: { deleted_count: countResult.count },
        message: `Successfully deleted ${countResult.count} products`
      });
    } catch (error) {
      console.error('Delete all products error:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }

  async bulkCreateProducts(req: AuthRequest, res: Response) {
    try {
      const { products } = req.body;

      if (!products || !Array.isArray(products)) {
        return res.status(400).json({
          success: false,
          error: 'Products array is required'
        });
      }

      let createdCount = 0;
      const errors: any[] = [];

      for (const productData of products) {
        try {
          if (!productData.name || !productData.sale_price) {
            errors.push({
              product: productData,
              error: 'Name and sale price are required'
            });
            continue;
          }

          // Check if SKU already exists
          const existingProduct = await Database.getInstance().get(
            'SELECT id FROM products WHERE sku = ?',
            [productData.sku]
          );

          if (existingProduct) {
            errors.push({
              product: productData,
              error: 'SKU already exists'
            });
            continue;
          }

          const result = await Database.getInstance().run(
            `INSERT INTO products (
              sku, barcode, name, description, category_id, unit,
              purchase_price, sale_price, wholesale_price, stock_quantity,
              min_stock_level, image_url
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
              productData.sku,
              productData.barcode || null,
              productData.name,
              productData.description || null,
              productData.category_id || null,
              productData.unit || 'cÃ¡i',
              productData.purchase_price || 0,
              productData.sale_price,
              productData.wholesale_price || null,
              productData.stock_quantity || 0,
              productData.min_stock_level || 0,
              productData.image_url || null
            ]
          );

          // Create inventory transaction for initial stock
          if (productData.stock_quantity && productData.stock_quantity > 0) {
            await Database.getInstance().run(
              `INSERT INTO inventory_transactions (
                product_id, transaction_type, reference_type, quantity, 
                unit_price, notes, user_id
              ) VALUES (?, 'in', 'adjustment', ?, ?, 'Initial stock (bulk import)', ?)`,
              [
                result.lastID,
                productData.stock_quantity,
                productData.purchase_price || 0,
                req.user?.id
              ]
            );
          }

          createdCount++;
        } catch (error) {
          errors.push({
            product: productData,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      }

      res.json({
        success: true,
        data: {
          created_count: createdCount,
          errors: errors
        },
        message: `Bulk create completed. Created: ${createdCount}, Errors: ${errors.length}`
      });
    } catch (error) {
      console.error('Bulk create products error:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }

  async exportProducts(req: AuthRequest, res: Response) {
    try {
      console.log('Export products called - using MySQL database');
      
      // Use MySQL database connection
      const db = DatabaseConnection.getInstance();
      const products = await db.all(
        `SELECT p.*, c.name as category_name 
         FROM products p 
         LEFT JOIN categories c ON p.category_id = c.id 
         ORDER BY p.name`
      );

      console.log('Products fetched from MySQL database:', products.length);

      // Prepare data for Excel export with 20 columns (same as import expects)
      const excelData = products.map((product: any, index: number) => ({
        'STT': index + 1,
        'MÃ£ SKU': product.sku || '',
        'MÃ£ váº¡ch': product.barcode || '',
        'TÃªn sáº£n pháº©m': product.name || '',
        'MÃ´ táº£': product.description || '',
        'Danh má»¥c': product.category_name || 'ChÆ°a phÃ¢n loáº¡i',
        'ÄÆ¡n vá» tÃ­nh': product.unit || '',
        'GiÃ¡ vá»n (VNÄ)': product.purchase_price ? Number(product.purchase_price).toLocaleString('vi-VN') : '0',
        'GiÃ¡ bÃ¡n láº» (VNÄ)': product.sale_price ? Number(product.sale_price).toLocaleString('vi-VN') : '0',
        'GiÃ¡ bÃ¡n sá» (VNÄ)': product.wholesale_price ? Number(product.wholesale_price).toLocaleString('vi-VN') : '0',
        'Tá»n kho hiá»n táº¡i': product.stock_quantity || 0,
        'Tá»n kho tá»i thiá»u': product.min_stock_level || 0,
        'Tá»n kho tá»i Äa': product.max_stock_level || 0,
        'Tráº¡ng thÃ¡i': product.is_active ? 'Äang hoáº¡t Äá»ng' : 'Táº¡m dá»«ng',
        'URL hÃ¬nh áº£nh': product.image_url || '',
        'NgÃ y táº¡o': product.created_at ? new Date(product.created_at).toLocaleString('vi-VN') : '',
        'NgÃ y cáº­p nháº­t': product.updated_at ? new Date(product.updated_at).toLocaleString('vi-VN') : '',
        'Lá»£i nhuáº­n (VNÄ)': product.sale_price && product.purchase_price ? 
          (Number(product.sale_price) - Number(product.purchase_price)).toLocaleString('vi-VN') : '0',
        'Tá»· lá» lá»£i nhuáº­n (%)': product.sale_price && product.purchase_price && Number(product.purchase_price) > 0 ? 
          (((Number(product.sale_price) - Number(product.purchase_price)) / Number(product.purchase_price)) * 100).toFixed(2) + '%' : '0%',
        'GiÃ¡ trá» tá»n kho (VNÄ)': product.stock_quantity && product.purchase_price ? 
          (Number(product.stock_quantity) * Number(product.purchase_price)).toLocaleString('vi-VN') : '0'
      }));

      console.log('Excel data prepared with', excelData.length, 'products and 20 columns');

      // Create workbook and worksheet
      const workbook = XLSX.utils.book_new();
      const worksheet = XLSX.utils.json_to_sheet(excelData);

      // Set column widths to match import template
      const colWidths = [
        { width: 8 },   // STT
        { width: 15 },  // MÃ£ SKU
        { width: 18 },  // MÃ£ váº¡ch
        { width: 35 },  // TÃªn sáº£n pháº©m
        { width: 40 },  // MÃ´ táº£
        { width: 20 },  // Danh má»¥c
        { width: 15 },  // ÄÆ¡n vá» tÃ­nh
        { width: 18 },  // GiÃ¡ vá»n
        { width: 20 },  // GiÃ¡ bÃ¡n láº»
        { width: 18 },  // GiÃ¡ bÃ¡n sá»
        { width: 18 },  // Tá»n kho hiá»n táº¡i
        { width: 18 },  // Tá»n kho tá»i thiá»u
        { width: 18 },  // Tá»n kho tá»i Äa
        { width: 15 },  // Tráº¡ng thÃ¡i
        { width: 25 },  // URL hÃ¬nh áº£nh
        { width: 20 },  // NgÃ y táº¡o
        { width: 20 },  // NgÃ y cáº­p nháº­t
        { width: 18 },  // Lá»£i nhuáº­n
        { width: 20 },  // Tá»· lá» lá»£i nhuáº­n
        { width: 22 }   // GiÃ¡ trá» tá»n kho
      ];
      worksheet['!cols'] = colWidths;

      XLSX.utils.book_append_sheet(workbook, worksheet, 'Danh sÃ¡ch sáº£n pháº©m');

      // Generate Excel file buffer
      const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });

      console.log('Excel buffer created, size:', buffer.length);

      // Set response headers for file download
      const fileName = `Danh_sach_san_pham_${new Date().toISOString().split('T')[0]}.xlsx`;
      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
      res.setHeader('Content-Length', buffer.length);

      console.log('Headers set, sending file:', fileName, 'with', products.length, 'products');
      res.send(buffer);
    } catch (error) {
      console.error('Export products error:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  async testExportProducts(req: any, res: Response) {
    try {
      console.log('Export products called - fetching real data from database');
      
      // Get all real products from database with full information
      const db = SQLiteDatabase.getInstance();
      console.log('SQLite database instance created');
      
      const products = await db.all(
        `SELECT p.*, c.name as category_name 
         FROM products p 
         LEFT JOIN categories c ON p.category_id = c.id 
         WHERE p.is_active = 1
         ORDER BY p.name`
      );
      
      console.log('Query executed, raw result:', products);

      console.log('Products fetched from database:', products.length);

      // If no products found, get sample data from database or create sample
      if (products.length === 0) {
        console.log('No products found, creating sample data for export');
        
        // Try to get all products (including inactive ones)
        const allProducts = await db.all(
          `SELECT p.*, c.name as category_name 
           FROM products p 
           LEFT JOIN categories c ON p.category_id = c.id 
           ORDER BY p.name`
        );
        
        if (allProducts.length > 0) {
          console.log('Found', allProducts.length, 'products (including inactive)');
          // Use all products if available
          const excelData = allProducts.map((product: any, index: number) => ({
            'STT': index + 1,
            'MÃ£ SKU': product.sku || '',
            'MÃ£ váº¡ch': product.barcode || '',
            'TÃªn sáº£n pháº©m': product.name || '',
            'MÃ´ táº£': product.description || '',
            'Danh má»¥c': product.category_name || 'ChÆ°a phÃ¢n loáº¡i',
            'ÄÆ¡n vá» tÃ­nh': product.unit || '',
            'GiÃ¡ vá»n (VNÄ)': product.purchase_price ? product.purchase_price.toLocaleString('vi-VN') : '0',
            'GiÃ¡ bÃ¡n láº» (VNÄ)': product.sale_price ? product.sale_price.toLocaleString('vi-VN') : '0',
            'GiÃ¡ bÃ¡n sá» (VNÄ)': product.wholesale_price ? product.wholesale_price.toLocaleString('vi-VN') : '0',
            'Tá»n kho hiá»n táº¡i': product.stock_quantity || 0,
            'Tá»n kho tá»i thiá»u': product.min_stock_level || 0,
            'Tá»n kho tá»i Äa': product.max_stock_level || 0,
            'Tráº¡ng thÃ¡i': product.is_active ? 'Äang hoáº¡t Äá»ng' : 'Táº¡m dá»«ng',
            'URL hÃ¬nh áº£nh': product.image_url || '',
            'NgÃ y táº¡o': product.created_at ? new Date(product.created_at).toLocaleString('vi-VN') : '',
            'NgÃ y cáº­p nháº­t': product.updated_at ? new Date(product.updated_at).toLocaleString('vi-VN') : '',
            'Lá»£i nhuáº­n (VNÄ)': product.sale_price && product.purchase_price ? 
              (product.sale_price - product.purchase_price).toLocaleString('vi-VN') : '0',
            'Tá»· lá» lá»£i nhuáº­n (%)': product.sale_price && product.purchase_price && product.purchase_price > 0 ? 
              (((product.sale_price - product.purchase_price) / product.purchase_price) * 100).toFixed(2) + '%' : '0%',
            'GiÃ¡ trá» tá»n kho (VNÄ)': product.stock_quantity && product.purchase_price ? 
              (product.stock_quantity * product.purchase_price).toLocaleString('vi-VN') : '0'
          }));
          
          // Create workbook and worksheet for all products
          const workbook = XLSX.utils.book_new();
          const worksheet = XLSX.utils.json_to_sheet(excelData);

          // Auto-size columns
          const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
          const colWidths: any[] = [];
          const headers = Object.keys(excelData[0]);
          
          for (let C = range.s.c; C <= range.e.c; ++C) {
            let maxWidth = headers[C] ? headers[C].length : 10;
            for (let R = range.s.r; R <= range.e.r; ++R) {
              const cellAddress = XLSX.utils.encode_cell({ c: C, r: R });
              const cell = worksheet[cellAddress];
              if (cell && cell.v) {
                const cellLength = cell.v.toString().length;
                if (cellLength > maxWidth) {
                  maxWidth = cellLength;
                }
              }
            }
            colWidths[C] = { width: Math.min(Math.max(maxWidth + 2, 12), 60) };
          }
          worksheet['!cols'] = colWidths;

          XLSX.utils.book_append_sheet(workbook, worksheet, 'Táº¥t cáº£ sáº£n pháº©m');

          const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
          const currentDate = new Date().toISOString().split('T')[0];
          const fileName = `Tat_ca_san_pham_${currentDate}.xlsx`;
          
          res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
          res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
          res.setHeader('Content-Length', buffer.length);
          res.setHeader('Cache-Control', 'no-cache');

          console.log('Sending Excel file with all products:', fileName);
          return res.send(buffer);
        } else {
          // Create sample data if no products at all
          const sampleData = [{
            'STT': 1,
            'MÃ£ SKU': 'SAMPLE001',
            'MÃ£ váº¡ch': '1234567890123',
            'TÃªn sáº£n pháº©m': 'Sáº£n pháº©m máº«u',
            'MÃ´ táº£': 'ÄÃ¢y lÃ  dá»¯ liá»u máº«u Äá» demo chá»©c nÄng xuáº¥t Excel',
            'Danh má»¥c': 'Danh má»¥c máº«u',
            'ÄÆ¡n vá» tÃ­nh': 'CÃ¡i',
            'GiÃ¡ vá»n (VNÄ)': '10,000',
            'GiÃ¡ bÃ¡n láº» (VNÄ)': '15,000',
            'GiÃ¡ bÃ¡n sá» (VNÄ)': '12,000',
            'Tá»n kho hiá»n táº¡i': 100,
            'Tá»n kho tá»i thiá»u': 10,
            'Tá»n kho tá»i Äa': 1000,
            'Tráº¡ng thÃ¡i': 'Äang hoáº¡t Äá»ng',
            'URL hÃ¬nh áº£nh': '',
            'NgÃ y táº¡o': new Date().toLocaleString('vi-VN'),
            'NgÃ y cáº­p nháº­t': new Date().toLocaleString('vi-VN'),
            'Lá»£i nhuáº­n (VNÄ)': '5,000',
            'Tá»· lá» lá»£i nhuáº­n (%)': '50.00%',
            'GiÃ¡ trá» tá»n kho (VNÄ)': '1,000,000'
          }];
          
          // Create workbook for sample data
          const workbook = XLSX.utils.book_new();
          const worksheet = XLSX.utils.json_to_sheet(sampleData);
          XLSX.utils.book_append_sheet(workbook, worksheet, 'Dá»¯ liá»u máº«u');

          const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
          const currentDate = new Date().toISOString().split('T')[0];
          const fileName = `Du_lieu_mau_${currentDate}.xlsx`;
          
          res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
          res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
          res.setHeader('Content-Length', buffer.length);
          res.setHeader('Cache-Control', 'no-cache');

          console.log('Sending sample Excel file:', fileName);
          return res.send(buffer);
        }
      }

      // Prepare complete data for Excel export with all columns
      const excelData = products.map((product: any) => ({
        'STT': products.indexOf(product) + 1,
        'MÃ£ SKU': product.sku || '',
        'MÃ£ váº¡ch': product.barcode || '',
        'TÃªn sáº£n pháº©m': product.name || '',
        'MÃ´ táº£': product.description || '',
        'Danh má»¥c': product.category_name || 'ChÆ°a phÃ¢n loáº¡i',
        'ÄÆ¡n vá» tÃ­nh': product.unit || '',
        'GiÃ¡ vá»n (VNÄ)': product.purchase_price ? product.purchase_price.toLocaleString('vi-VN') : '0',
        'GiÃ¡ bÃ¡n láº» (VNÄ)': product.sale_price ? product.sale_price.toLocaleString('vi-VN') : '0',
        'GiÃ¡ bÃ¡n sá» (VNÄ)': product.wholesale_price ? product.wholesale_price.toLocaleString('vi-VN') : '0',
        'Tá»n kho hiá»n táº¡i': product.stock_quantity || 0,
        'Tá»n kho tá»i thiá»u': product.min_stock_level || 0,
        'Tá»n kho tá»i Äa': product.max_stock_level || 0,
        'Tráº¡ng thÃ¡i': product.is_active ? 'Äang hoáº¡t Äá»ng' : 'Táº¡m dá»«ng',
        'URL hÃ¬nh áº£nh': product.image_url || '',
        'NgÃ y táº¡o': product.created_at ? new Date(product.created_at).toLocaleString('vi-VN') : '',
        'NgÃ y cáº­p nháº­t': product.updated_at ? new Date(product.updated_at).toLocaleString('vi-VN') : '',
        'Lá»£i nhuáº­n (VNÄ)': product.sale_price && product.purchase_price ? 
          (product.sale_price - product.purchase_price).toLocaleString('vi-VN') : '0',
        'Tá»· lá» lá»£i nhuáº­n (%)': product.sale_price && product.purchase_price && product.purchase_price > 0 ? 
          (((product.sale_price - product.purchase_price) / product.purchase_price) * 100).toFixed(2) + '%' : '0%',
        'GiÃ¡ trá» tá»n kho (VNÄ)': product.stock_quantity && product.purchase_price ? 
          (product.stock_quantity * product.purchase_price).toLocaleString('vi-VN') : '0'
      }));

      console.log('Excel data prepared with', excelData.length, 'products and', Object.keys(excelData[0]).length, 'columns');

      // Create workbook and worksheet
      const workbook = XLSX.utils.book_new();
      const worksheet = XLSX.utils.json_to_sheet(excelData);

      // Auto-size columns with better width calculation
      const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
      const colWidths: any[] = [];
      
      // Get column headers for better width calculation
      const headers = Object.keys(excelData[0]);
      
      for (let C = range.s.c; C <= range.e.c; ++C) {
        let maxWidth = headers[C] ? headers[C].length : 10;
        
        for (let R = range.s.r; R <= range.e.r; ++R) {
          const cellAddress = XLSX.utils.encode_cell({ c: C, r: R });
          const cell = worksheet[cellAddress];
          if (cell && cell.v) {
            const cellLength = cell.v.toString().length;
            if (cellLength > maxWidth) {
              maxWidth = cellLength;
            }
          }
        }
        
        // Set reasonable column width limits
        colWidths[C] = { width: Math.min(Math.max(maxWidth + 2, 12), 60) };
      }
      worksheet['!cols'] = colWidths;

      // Add worksheet to workbook with Vietnamese name
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Danh sÃ¡ch sáº£n pháº©m');

      // Generate Excel file buffer
      const buffer = XLSX.write(workbook, {
        type: 'buffer',
        bookType: 'xlsx'
      });

      console.log('Excel buffer created successfully, size:', buffer.length, 'bytes');

      // Set response headers for file download
      const currentDate = new Date().toISOString().split('T')[0];
      const fileName = `Danh_sach_san_pham_${currentDate}.xlsx`;
      
      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
      res.setHeader('Content-Length', buffer.length);
      res.setHeader('Cache-Control', 'no-cache');

      console.log('Sending Excel file:', fileName);
      res.send(buffer);
      
    } catch (error) {
      console.error('Export products error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to export products',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  async importProducts(req: any, res: Response) {
    try {
      console.log('Import products called');
      
      if (!req.file) {
        return res.status(400).json({
          success: false,
          error: 'No file uploaded'
        });
      }

      console.log('File received:', req.file.originalname, 'Size:', req.file.size);

      // Read Excel file from buffer
      const workbook = XLSX.read(req.file.buffer, { type: 'buffer' });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      
      // Convert to JSON
      const jsonData = XLSX.utils.sheet_to_json(worksheet);
      console.log('Excel data parsed, rows:', jsonData.length);

      if (jsonData.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'File Excel khÃ´ng cÃ³ dá»¯ liá»u'
        });
      }

      const db = Database.getInstance();
      let successCount = 0;
      let errorCount = 0;
      const errors: any[] = [];

      // Process each row
      for (let i = 0; i < jsonData.length; i++) {
        const row: any = jsonData[i];
        
        try {
          // Skip empty rows
          const hasData = Object.values(row).some(value => 
            value !== null && value !== undefined && String(value).trim() !== ''
          );
          
          if (!hasData) {
            console.log(`Skipping empty row ${i + 1}`);
            continue;
          }

          // Get category ID by name
          const categoryName = row['Danh má»¥c'] || row['Category'] || row['category'] || '';
          let categoryId = 1; // Default to first category
          
          if (categoryName) {
            const categoryResult = await db.get(
              'SELECT id FROM categories WHERE name = ? OR name LIKE ?',
              [categoryName, `%${categoryName}%`]
            );
            if (categoryResult) {
              categoryId = categoryResult.id;
            }
          }

          // Map Excel columns to database fields - matching the actual file structure
          const productData = {
            sku: row['MÃ£ hÃ ng'] || row['MÃ£ SKU'] || row['SKU'] || row['sku'] || `AUTO_${Date.now()}_${i}`,
            barcode: row['MÃ£ váº¡ch'] || row['Barcode'] || row['barcode'] || '',
            name: row['TÃªn hÃ ng'] || row['TÃªn sáº£n pháº©m'] || row['Product Name'] || row['name'] || '',
            description: row['MÃ´ táº£'] || row['Description'] || row['description'] || '',
            unit: row['ÄÆ¡n vá» tÃ­nh'] || row['Unit'] || row['unit'] || 'CÃ¡i',
            purchase_price: this.parsePrice(row['GiÃ¡ vá»n'] || row['GiÃ¡ vá»n (VNÄ)'] || row['Purchase Price'] || row['purchase_price'] || 0),
            sale_price: this.parsePrice(row['GiÃ¡ bÃ¡n'] || row['GiÃ¡ bÃ¡n láº» (VNÄ)'] || row['Sale Price'] || row['sale_price'] || 0),
            wholesale_price: this.parsePrice(row['GiÃ¡ bÃ¡n sá»'] || row['GiÃ¡ bÃ¡n sá» (VNÄ)'] || row['Wholesale Price'] || row['wholesale_price'] || 0),
            stock_quantity: parseInt(row['Tá»n kho'] || row['Tá»n kho hiá»n táº¡i'] || row['Stock'] || row['stock_quantity'] || '0'),
            min_stock_level: parseInt(row['Tá»n kho tá»i thiá»u'] || row['Min Stock'] || row['min_stock_level'] || '5'),
            max_stock_level: parseInt(row['Tá»n kho tá»i Äa'] || row['Max Stock'] || row['max_stock_level'] || '1000'),
            category_id: categoryId,
            is_active: (row['Tráº¡ng thÃ¡i'] === 'Táº¡m dá»«ng' || row['Status'] === 'Inactive') ? 0 : 1,
            image_url: row['URL hÃ¬nh áº£nh'] || row['Image URL'] || row['image_url'] || null
          };

          // Debug log for first few rows
          if (i < 5) {
            console.log(`Row ${i + 1} data:`, JSON.stringify(productData, null, 2));
          }

          // Validate required fields
          if (!productData.name || !productData.sale_price) {
            errors.push({
              row: i + 1,
              error: `Thiáº¿u tÃªn sáº£n pháº©m hoáº·c giÃ¡ bÃ¡n. Name: '${productData.name}', Sale price: '${productData.sale_price}'`,
              data: row
            });
            errorCount++;
            continue;
          }

          // Check if product exists by SKU
          const existingProduct = await db.get(
            'SELECT id FROM products WHERE sku = ?',
            [productData.sku]
          );

          if (existingProduct) {
            // Update existing product
            await db.run(
              `UPDATE products SET 
               name = ?, description = ?, unit = ?, purchase_price = ?, 
               sale_price = ?, wholesale_price = ?, stock_quantity = ?, 
               min_stock_level = ?, max_stock_level = ?, is_active = ?, 
               image_url = ?, updated_at = CURRENT_TIMESTAMP
               WHERE sku = ?`,
              [
                productData.name, productData.description, productData.unit,
                productData.purchase_price, productData.sale_price, productData.wholesale_price,
                productData.stock_quantity, productData.min_stock_level, productData.max_stock_level,
                productData.is_active, productData.image_url, productData.sku
              ]
            );
            console.log(`Updated product: ${productData.name}`);
          } else {
            // Insert new product
            await db.run(
              `INSERT INTO products (
                sku, barcode, name, description, category_id, unit,
                purchase_price, sale_price, wholesale_price, stock_quantity,
                min_stock_level, max_stock_level, is_active, image_url
              ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
              [
                productData.sku, productData.barcode, productData.name, productData.description,
                productData.category_id, productData.unit, productData.purchase_price,
                productData.sale_price, productData.wholesale_price, productData.stock_quantity,
                productData.min_stock_level, productData.max_stock_level, productData.is_active,
                productData.image_url
              ]
            );
            console.log(`Inserted new product: ${productData.name}`);
          }

          successCount++;
        } catch (error) {
          console.error(`Error processing row ${i + 1}:`, error);
          errors.push({
            row: i + 1,
            error: error instanceof Error ? error.message : 'Unknown error',
            data: row
          });
          errorCount++;
        }
      }

      console.log(`Import completed. Success: ${successCount}, Errors: ${errorCount}`);

      res.json({
        success: true,
        data: {
          total_rows: jsonData.length,
          success_count: successCount,
          error_count: errorCount,
          errors: errors.slice(0, 10) // Limit error details to first 10
        },
        message: `Nháº­p thÃ nh cÃ´ng ${successCount} sáº£n pháº©m. Lá»i: ${errorCount}`
      });

    } catch (error) {
      console.error('Import products error:', error);
      res.status(500).json({
        success: false,
        error: 'Lá»i khi nháº­p file Excel',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  private parsePrice(value: any): number {
    if (typeof value === 'number') return value;
    if (typeof value === 'string') {
      // Remove commas, currency symbols, and parse
      const cleaned = value.replace(/[,\sâ«VNÄ]/g, '');
      const parsed = parseFloat(cleaned);
      return isNaN(parsed) ? 0 : parsed;
    }
    return 0;
  }

  async getDashboardStats(req: AuthRequest, res: Response) {
    try {
      const db = Database.getInstance();
      
      // Get total products count
      const totalProductsResult = await db.get(
        'SELECT COUNT(*) as total FROM products'
      );
      const totalProducts = totalProductsResult?.total || 0;
      
      // Get out of stock count
      const outOfStockResult = await db.get(
        'SELECT COUNT(*) as count FROM products WHERE stock_quantity <= 0'
      );
      const outOfStock = outOfStockResult?.count || 0;
      
      // Get low stock count (stock <= min_stock_level and stock > 0)
      const lowStockResult = await db.get(
        'SELECT COUNT(*) as count FROM products WHERE stock_quantity > 0 AND stock_quantity <= min_stock_level'
      );
      const lowStock = lowStockResult?.count || 0;
      
      // Get total inventory value (stock_quantity * purchase_price)
      const totalValueResult = await db.get(
        'SELECT SUM(stock_quantity * purchase_price) as total_value FROM products WHERE stock_quantity > 0 AND purchase_price > 0'
      );
      const totalValue = totalValueResult?.total_value || 0;

      res.json({
        success: true,
        data: {
          total_products: totalProducts,
          out_of_stock: outOfStock,
          low_stock: lowStock,
          total_inventory_value: Number(totalValue)
        }
      });
    } catch (error) {
      console.error('Get dashboard stats error:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
} 